<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.25
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="chore-async-job-processing-framework-for-ruby">Chore: Async Job Processing Framework For Ruby</h1>

<p><a href="https://travis-ci.org/Tapjoy/chore"><img src="https://travis-ci.org/Tapjoy/chore.svg?branch=master" alt="Build Status"></a></p>

<h2 id="about">About</h2>

<p>Chore is a pluggable, multi-backend job processing framework. It was built from the ground up to be extremely flexible.
We hope that you find integrating and using Chore to be as pleasant as we do.</p>

<p>The full docs for Chore can always be found at <a href="https://tapjoy.github.io/chore">https://tapjoy.github.io/chore</a>.</p>

<h2 id="configuration">Configuration</h2>

<p>Chore can be integrated with any Ruby-based project by following these instructions:</p>

<ol>
<li><p>Add <code>chore-core</code> to the Gemfile</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>chore-core</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>~&gt; 4.0.0</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>When using SQS, also add <code>dalli</code> to use for <code>memcached</code>-based deduplication:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>dalli</span><span class='tstring_end'>&#39;</span></span>
</code></pre></li>
<li><p>Create a <code>Chorefile</code> file in the root of the project directory. While Chore itself can be configured from this file,
it&#39;s primarily used to direct the Chore binstub toward the root of the application so that it can locate all of the
dependencies and required code.</p>

<pre class="code ruby"><code class="ruby">--require=./&lt;FILE_TO_LOAD&gt;
</code></pre>

<p>Make sure that <code>--require</code> points to the main entry point for the application. If integrating with a Rails app,
point it to the application directory and Chore will handle loading the correct files on its own.</p></li>
<li><p>When using SQS, ensure that AWS credentials exist in the environment (e.g. but not limited to <code>AWS_ACCESS_KEY_ID</code> &amp;
<code>AWS_SECRET_ACCESS_KEY</code> environment variables) and an AWS region is set (e.g. <code>AWS_REGION</code> environment variable) so that
Chore can authenticate with AWS.</p>

<p>By default, Chore will run over all queues it detects among the required files. If different behavior is desired,
use one of the following flags:</p>

<pre class="code ruby"><code class="ruby"># Note that only one of these options may be used, not both. Chore will quit
# if both options are specified.
--queues QUEUE1,QUEUE2... # a list of queues to process
--except-queues QUEUE1,QUEUE2... # a list of queues _not_ to process
</code></pre></li>
<li><p>Chore has many more options, which can be viewed by executing <code>bundle exec chore --help</code></p></li>
</ol>

<h3 id="tips-for-configuring-chore">Tips For Configuring Chore</h3>

<p>For Rails, it can be necessary to add the jobs directory to the eager loading path, found in <code>application.rb</code>. A similar
approach for most apps using jobs is likely needed, unless the jobs are placed into a directory that is already eager
loaded by the application. One example of this might be:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_eager_load_paths'>eager_load_paths</span> <span class='op'>+=</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_root'>root</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>app</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>jobs</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
</code></pre>

<p>However, due to the way <code>eager_load_paths</code> works in Rails, this may only solve the issue in the production environment.
It can also be useful useful for other environments to have something like this in an <code>config/initializers/chore.rb</code>
file, although the job files can be loaded in just about any way.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>if</span> <span class='op'>!</span><span class='const'>Rails</span><span class='period'>.</span><span class='id identifier rubyid_env'>env</span><span class='period'>.</span><span class='id identifier rubyid_production?'>production?</span>
  <span class='const'>Dir</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='const'>Rails</span><span class='period'>.</span><span class='id identifier rubyid_root'>root</span><span class='embexpr_end'>}</span><span class='tstring_content'>/app/jobs/**/*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_file'>file</span><span class='op'>|</span>
    <span class='id identifier rubyid_require'>require</span> <span class='id identifier rubyid_file'>file</span> <span class='kw'>unless</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_directory?'>directory?</span><span class='lparen'>(</span><span class='id identifier rubyid_file'>file</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h3 id="producing-consuming-jobs">Producing &amp; Consuming Jobs</h3>

<p>When it comes to configuring Chore, there are 2 main use configurations - as a producer of messages, or as a consumer of
messages. The consuming context may also messages if necessary, as it is running as its own isolated instance of the
application.</p>

<p>For producers, all of the Chore configuration must be in an initializer.</p>

<p>For consumers, a Chorefile must be used. A Chorefile <em>plus</em> an initializer is also a good pattern.</p>

<p>Here&#39;s example of how to configure chore via an initializer:</p>

<pre class="code ruby"><code class="ruby">Chore.configure do |c|
  c.concurrency = 16
  c.worker_strategy = Chore::Strategy::ForkedWorkerStrategy
  c.max_attempts = 100
  ...
  c.batch_size = 50
  c.batch_timeout = 20
end
</code></pre>

<p>Because it is like that the same application serves as the basis for both producing and consuming messages, and there
will already be a considerable amount of configuration in the Producer, it makes sense to use Chorefile to simply
provide the <code>require</code> option and stick to the initializer for the rest of the configuration to keep things DRY.</p>

<p>However, like many aspects of Chore, it is ultimately up to the developer to decide which use case fits their needs
best. Chore is happy to be configured in almost any way a developer desires.</p>

<h2 id="integration">Integration</h2>

<p>This section assumes <code>foreman</code> is being used to execute (or export the run commands of) the application, but it is not
 strictly necessary.</p>

<ol>
<li><p>Add an appropriate line to the <code>Procfile</code>:</p>

<pre class="code ruby"><code class="ruby">jobs: bundle exec chore -c config/chore.config
</code></pre></li>
<li><p>If the queues do not exist, they must be created before the application can produce/consumeÂ Chore jobs:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aws-sdk-sqs</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_sqs'>sqs</span> <span class='op'>=</span> <span class='const'>Aws</span><span class='op'>::</span><span class='const'>SQS</span><span class='op'>::</span><span class='const'>Client</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_sqs'>sqs</span><span class='period'>.</span><span class='id identifier rubyid_create_queue'>create_queue</span><span class='lparen'>(</span><span class='label'>queue_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test_queue</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
</code></pre></li>
<li><p>Finally, start the application as usual</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_bundle'>bundle</span> <span class='id identifier rubyid_exec'>exec</span> <span class='id identifier rubyid_foreman'>foreman</span> <span class='id identifier rubyid_start'>start</span>
</code></pre></li>
</ol>

<h2 id="chore-job"><code>Chore::Job</code></h2>

<p>A <code>Chore::Job</code> is any class with <code>include Chore::Job</code> and implements a <code>perform(*args)</code> instance method. Here is an
example job class:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>TestJob</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="Chore.html" title="Chore (module)">Chore</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Chore/Job.html" title="Chore::Job (module)">Job</a></span></span>
  <span class='id identifier rubyid_queue_options'>queue_options</span> <span class='symbol'>:name</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test_queue</span><span class='tstring_end'>&#39;</span></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_perform'>perform</span><span class='lparen'>(</span><span class='id identifier rubyid_args'>args</span><span class='op'>=</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
    <span class='const'><span class='object_link'><a href="Chore.html" title="Chore (module)">Chore</a></span></span><span class='period'>.</span><span class='id identifier rubyid_logger'><span class='object_link'><a href="Chore.html#logger-class_method" title="Chore.logger (method)">logger</a></span></span><span class='period'>.</span><span class='id identifier rubyid_debug'>debug</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>My first async job</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>This job declares that the name of the queue it uses is <code>test_queue</code>, set in the <code>queue_options</code> method.</p>

<h3 id="chore-job-perform-signatures"><code>Chore::Job</code> &amp; <code>perform</code> Signatures</h3>

<p>The perform method signature can have explicit argument names, but in practice this makes changing the signature more
difficult later on. Once a <code>Chore::Job</code> is in production and being used at a constant rate, it becomes problematic to
begin mixing versions of the job with non-matching signatures.</p>

<p>While this is able to be overcome with a number of techniques, such as versioning jobs/queues, it increases the
complexity of making changes.</p>

<p>The simplest way to structure job signatures is to treat the arguments as a hash. This enables maintaining forwards and
backwards compatibility between signature changes with the same job class.</p>

<p>However, Chore is ultimately agnostic in this regard and will allow explicit arguments in signatures as easily as using
a simple hash; the choice is left to the developer.</p>

<h3 id="chore-job-publishing-jobs"><code>Chore::Job</code> &amp; Publishing Jobs</h3>

<p>Now that there&#39;s a test job, publishing an instance of the job is as simple as:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>TestJob</span><span class='period'>.</span><span class='id identifier rubyid_perform_async'>perform_async</span><span class='lparen'>(</span><span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>message</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>YES, DO THAT THING.</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='rparen'>)</span>
</code></pre>

<p>It&#39;s advisable to specify the Publisher Chore uses to send messages globally, so that it can easily be modified based on
the environment. To do this, add a configuration block to an initializer:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Chore.html" title="Chore (module)">Chore</a></span></span><span class='period'>.</span><span class='id identifier rubyid_configure'><span class='object_link'><a href="Chore.html#configure-class_method" title="Chore.configure (method)">configure</a></span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span>
  <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_publisher'>publisher</span> <span class='op'>=</span> <span class='const'>Some</span><span class='op'>::</span><span class='const'>Other</span><span class='op'>::</span><span class='const'>Publisher</span>
<span class='kw'>end</span>
</code></pre>

<p>It is worth noting that any option that can be set via config file or command-line args can also be set in a configure
block.</p>

<p>If a global publisher is set, it can be overridden on a per-job basis by specifying the publisher in <code>queue_options</code>.</p>

<h2 id="retry-backoff-strategy">Retry Backoff Strategy</h2>

<p>Chore has basic support for delaying retries of a failed job using a step function. Currently the only queue that
supports this functionality is SQS; all others will simply ignore the delay setting.</p>

<h3 id="setup">Setup</h3>

<p>The <code>:backoff</code> option for a queue expects a lambda that takes a single <code>UnitOfWork</code> argument. The return should be a
number of seconds to delay the next attempt.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_queue_options'>queue_options</span> <span class='symbol'>:name</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>nameOfQueue</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
  <span class='symbol'>:backoff</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_lambda'>lambda</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_work'>work</span><span class='op'>|</span> <span class='id identifier rubyid_work'>work</span><span class='period'>.</span><span class='id identifier rubyid_current_attempt'>current_attempt</span> <span class='op'>**</span> <span class='int'>2</span> <span class='rbrace'>}</span> <span class='comment'># Exponential backoff
</span></code></pre>

<h3 id="using-the-backoff">Using The Backoff</h3>

<p>If there is a <code>:backoff</code> option supplied, any failures will delay the next attempt by the result of that lambda.</p>

<h3 id="notes-on-sqs-delays">Notes On SQS &amp; Delays</h3>

<p>Read more details about SQS and Delays <a href="docs/Delayed%20Jobs.md">here</a></p>

<h2 id="hooks">Hooks</h2>

<p>A number of hooks, both global and per-job, exist in Chore for flexibility and convencience. Hooks should be named
<code>hook_name_identifier</code> where <code>identifier</code> is a descriptive string of chosen by the developer.</p>

<h3 id="global-hooks">Global Hooks</h3>

<ul>
<li><code>before_start</code></li>
<li><code>before_first_fork</code></li>
<li><code>before_fork</code></li>
<li><code>after_fork</code></li>
<li><code>around_fork</code></li>
<li><code>within_fork</code>

<ul>
<li>behaves similarly to <code>around_fork</code>, except that it is called <em>after</em> the worker process has been forked.
In contrast, <code>around_fork</code> is called by the parent process ( chore-master`)</li>
</ul></li>
<li><code>before_shutdown</code></li>
</ul>

<h2 id="filesystem-consumer-publisher-hooks">Filesystem Consumer/Publisher Hooks</h2>

<ul>
<li><code>on_fetch(job_file, job_json)</code></li>
</ul>

<h4 id="sqs-consumer-hooks">SQS Consumer Hooks</h4>

<ul>
<li><code>on_fetch(handle, body)</code></li>
</ul>

<h3 id="per-job">Per Job</h3>

<ul>
<li><code>before_publish</code></li>
<li><code>after_publish</code></li>
<li><code>before_perform(message)</code></li>
<li><code>after_perform(message)</code></li>
<li><code>on_rejected(message)</code></li>
<li><code>on_failure(message, error)</code></li>
<li><code>on_permanent_failure(queue_name, message, error)</code></li>
</ul>

<p>All per-job hooks can also be global hooks.</p>

<p>Hooks can be added to a job class like so:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>TestJob</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="Chore.html" title="Chore (module)">Chore</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Chore/Job.html" title="Chore::Job (module)">Job</a></span></span>
  <span class='id identifier rubyid_queue_options'>queue_options</span> <span class='symbol'>:name</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test_queue</span><span class='tstring_end'>&#39;</span></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_perform'>perform</span><span class='lparen'>(</span><span class='id identifier rubyid_args'>args</span><span class='op'>=</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
    <span class='comment'># Do something cool
</span>  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_before_perform_log'>before_perform_log</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>
    <span class='const'><span class='object_link'><a href="Chore.html" title="Chore (module)">Chore</a></span></span><span class='period'>.</span><span class='id identifier rubyid_logger'><span class='object_link'><a href="Chore.html#logger-class_method" title="Chore.logger (method)">logger</a></span></span><span class='period'>.</span><span class='id identifier rubyid_debug'>debug</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>About to do something cool with: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_message'>message</span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Global hooks can also be registered like so:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Chore.html" title="Chore (module)">Chore</a></span></span><span class='period'>.</span><span class='id identifier rubyid_add_hook'><span class='object_link'><a href="Chore.html#add_hook-class_method" title="Chore.add_hook (method)">add_hook</a></span></span> <span class='symbol'>:after_publish</span> <span class='kw'>do</span>
  <span class='comment'># Add handler code here
</span><span class='kw'>end</span>
</code></pre>

<h2 id="signals">Signals</h2>

<p>Signal handling can get complicated when there are multiple threads, process forks, and both signal handlers and
application code making use of mutexes.</p>

<p>To simplify the complexities around this, Chore introduces some additional behaviors on top of Ruby&#39;s default
<code>Signal.trap</code> implementation.  This functionality is primarily inspired by <code>sidekiq</code>&#39;s signal handling @
<a href="https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/cli.rb">https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/cli.rb</a>.</p>

<p>In particular Chore handles signals in a separate thread, and does so sequentially instead of being interrupt-driven.
See <code>Chore::Signal</code> for more details on the differences between Ruby&#39;s <code>Signal.trap</code> and Chore&#39;s <code>Chore::Signal.trap</code>.</p>

<p>Chore will respond to the following signals:</p>

<ul>
<li><code>INT</code> , <code>TERM</code>, <code>QUIT</code> - Chore will begin shutting down, taking steps to safely terminate workers and not interrupt
jobs in progress unless it believes they may be hung</li>
<li><code>USR1</code> - Re-opens logfiles, useful for handling log rotations</li>
</ul>

<h2 id="timeouts">Timeouts</h2>

<p>When using the forked worker strategy for processing jobs, inevitably there are cases in which child processes become
stuck.  This could result from deadlocks, hung network calls, tight loops, etc.  When these jobs hang, they consume
resources and can affect throughput.</p>

<p>To mitigate this, Chore has built-in monitoring of forked child processes. When a fork is created to process a batch of
work, that fork is assigned an expiration time -- if it doesn&#39;t complete by that time, the process is sent a <code>KILL</code>
signal.</p>

<p>Fork expiration times are determined from one of two places:</p>

<ol>
<li>The timeout associated with the queue.  For SQS queues, this is the visibility timeout.</li>
<li>The default queue timeout configured for Chore. For filesystem queues, this is the value used.</li>
</ol>

<p>For example, if a worker is processing a batch of 5 jobs and each job&#39;s queue has a timeout of 60s, then the expiration
time will be 5 minutes for the worker.</p>

<p>To change the default queue timeout (when one can&#39;t be inferred), do the following:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Chore.html" title="Chore (module)">Chore</a></span></span><span class='period'>.</span><span class='id identifier rubyid_configure'><span class='object_link'><a href="Chore.html#configure-class_method" title="Chore.configure (method)">configure</a></span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span>
  <span class='id identifier rubyid_c'>c</span><span class='period'>.</span><span class='id identifier rubyid_default_queue_timeout'>default_queue_timeout</span> <span class='op'>=</span> <span class='int'>3600</span>
<span class='kw'>end</span>
</code></pre>

<p>A reasonable timeout would be based on the maximum amount of time any job in the system is expected to run.  Keep in
mind that the process running the job may get killed if the job is running for too long.</p>

<h2 id="plugins">Plugins</h2>

<p>Chore has several plugin gems available, which extend its core functionality</p>

<p><a href="https://github.com/Tapjoy/chore-new_relic">New Relic</a> - Integrating Chore with New Relic</p>

<p><a href="https://github.com/Tapjoy/chore-airbrake">Airbrake</a> - Integrating Chore with Airbrake</p>

<h2 id="managing-chore-processes">Managing Chore Processes</h2>

<h3 id="sample-upstart">Sample Upstart</h3>

<p>There are lots of ways to create upstart scripts, so it&#39;s difficult to give a prescriptive example of the &quot;right&quot; way to
do it. However, here are some ideas from how we run it in production at Tapjoy:</p>

<p>For security reasons, a specific user should be specified that the process runs as. Switch to this user at the beginning
of the exec line</p>

<pre class="code bash"><code class="bash">su - $USER --command &#39;...&#39;
</code></pre>

<p>For the command to run Chore itself keeping all of the necessary environment variables in an env file that Upstart can
source on it&#39;s exec line, to prevent having to mix changing environment variables with having to change the upstart
script itself</p>

<pre class="code bash"><code class="bash">source $PATHTOENVVARS ;
</code></pre>

<p>After that, ensure Chore is running under the right ruby version. Additionally, <code>STDOUT</code> and <code>STDERR</code> can be redirected
to <code>logger</code> with an app name. This makes it easy to find information in syslog later on. Putting that all together looks
like:</p>

<pre class="code bash"><code class="bash">rvm use $RUBYVERSION do  bundle exec chore -c Chorefile  2&gt;&amp;1 | logger -t $APPNAME
</code></pre>

<p>There are many other ways to manage the Upstart file, but these are a few of the ways we prefer to do it. Putting it all
together, it looks something like:</p>

<pre class="code bash"><code class="bash">exec su - special_user --command &#39;\
  source /the/path/to/env ;\
  rvm use 2.4.1 do bundle exec chore -c Chorefile 2&gt;&amp;1 | logger chore-app ;&#39;
</code></pre>

<h3 id="locating-processes">Locating Processes</h3>

<p>As Chore does not keep a PID file, and has both a master and a potential number of workers, it may be difficult to
isolate the exact PID for the master process.</p>

<p>To find Chore master processes via <code>ps</code>, run the following:</p>

<pre class="code bash"><code class="bash">ps aux | grep bin/chore
</code></pre>

<p>or</p>

<pre class="code bash"><code class="bash">pgrep -f bin/chore
</code></pre>

<p>To find a list of only Chore worker processes:</p>

<pre class="code bash"><code class="bash">ps aux | grep chore-worker
</code></pre>

<p>or</p>

<pre class="code bash"><code class="bash">pgrep -f chore-worker
</code></pre>

<h2 id="copyright">Copyright</h2>

<p>Copyright (c) 2013 - 2020 Tapjoy. See <a href="LICENSE.txt">LICENSE.txt</a> for further details.</p>
</div></div>

      <div id="footer">
  Generated on Mon Sep 14 12:30:28 2020 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.25 (ruby-2.3.0).
</div>

    </div>
  </body>
</html>